<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>slogo_team07: DESIGN</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">slogo_team07
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Packages</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">DESIGN </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>#Design Document for SLogo <b>Team 7: Megan Gutter, Brandon Choi, James Mosca, Thomas Bagley</b></p>
<h2>Introduction</h2>
<p>The goal of creating this project is essentially to create a basic IDE. In terms of UI, the goal is to create a user interface in which it is clear where commands are to be typed, and make it easy for the user to write new functions. The goal for the back end is to be able to correctly handle and execute function inputs. We want to add as little code as possible when we enable the back end to handle new, different types of commands.</p>
<p>Our UI needs to be very flexible in terms of handling string input. The user is allowed to type whatever commands he/she wants. Once this input is handled on the back end, the WorldView window displays whatever output its told to. Also, new GUI features should be easy to add if needed. We can create this flexibility by having different objects for each of the windows of our front end(WorldView, CommandBox). UI flexibility will be tied to our ability to change what the user sees and how the user is able to interact with the program.</p>
<p>The back end needs to be designed so it's very open for extension. We need to constantly be able to add new functionality so that we can handle different types of user input. Our back end needs to be able to correctly execute functions based on the original string input that the back end receives.</p>
<p>Our World class takes on the role of the middle ground between the input and the visualization of the input. It can handle any string input and an error is thrown if syntax is determined to be incorrect. The World class also plays a role in the back end of our program. The parser is called by World in order to handle its string input. World isn't explicitly a controller class, because it takes on back end roles, but it performs a similar function by passing things between front end and back end.</p>
<h2>Overview</h2>
<p>Reference our UML design <a href="https://github.com/duke-compsci308-spring2015/slogo_team07/blob/master/UML%20Overview.jpg">HERE</a></p>
<p>Our program utilizes the classic model-view-controller architecture as follows:</p>
<p><em>Model / Back End</em> <br />
 Relevant classes: World (and subclasses), Turtle, Parser, CommandFactory, Command (and subclasses), ButtonFactory</p>
<p>The main component of our back end code is our World class. It holds an instance of the Turtle that is being moved and acted upon, a Parser that takes in the user's input and eventually sends out the appropriate Command(s), as well as the determined dimensions of the world. It is an abstract class and can be extended to be bounded or unbounded depending on the desired wrap around functionality. the two pairs of get and set methods allow the dimensions of the world to be changed dynamically. The listen() method is a crucial method that will call Turtle to execute all the commands in its queue of commands. This is essentially where all the movements, changes in direction, drawing, and other significant changes of the back end components in the program will occur.</p>
<p>The Turtle class is one of our most important classes as this is the character that is acted upon by the user's inputs. It contains a boolean pen that indicates whether it is drawing or not, a boolean visible, its coordinates in x and y, its degree of direction, a Queue of Commands that it can interate through and perform, as well as the Image that will represent it on the front end. We designed the Turtle in a way to minimize the data sharing between classes in terms of variables. Instead, we wanted to design our program so that entire Objects are passed around OR that all objects perform the functions that would otherwise require any of their fields. Therefore rather than passing specific coordinates to update for a Forward command, we instead call move() from the Turtle class to minimize the sharing of data. Though get and set methods still exist, we hope to eventually be able to get rid of these and perform all the necessary functions with maximum encapsulation.</p>
<p>The Parser takes in the inputted String and utilizes CommandFactory to return all the appropriate commands in a Queue so that the Turtle can act on them in order. Command is an abstract class that will be extended to all specific Command subclasses such as Forward. The HashMap&lt;String, Double&gt; variables will be used to store any and all variables inputted by the user so that the program can reference them whenever needed. The ButtonFactory class is what creates clickable versions of the past commands the user put in. Therefore, once the specific Command(s) is created, the ButtonFactory will initialize a Button to represent those actions and send it the UserInterface to become available for the user. The Buttons would be added to mySideBar.</p>
<p><em>Controller</em> <br />
 Relevant classes: WorldController</p>
<p>WorldController acts as the medium between the UserInterface (front end) and World and its necessary classes (back end). WorldController's clear() method clears the entire screen by erasing all the drawings. The getWorld() method returns the World with all of its new components to demonstrate movement, drawings, or any other visual changes that the back end is meant to represent. The update() method will be a simple method that utilizes the two previously mentioned helper methods.</p>
<p><em>View / Front End</em> <br />
 Relevant classes: UserInterface</p>
<p>The HBox CommandField is the text input where the user can type in commands he or she wants the Turtle to perform. The VBox mySideBar will contain the link to the HTML help page as well as the buttons representing past actions that are now easily clickable in order to repeat the respective previous actions. myWorldController is the instance of WorldController and will act as the middle ground between the UserInterface's front end and the rest of the code's back end. It's initialize() method creates all three of its field variables and components in order to get the program started. The refresh method gets the most up to date World and 'draws' it on the user's view.</p>
<p><em>Basic Overiew of a single command running:</em> <br />
 Say the program is started. <a class="el" href="../../d0/d4b/class_main.html">Main</a> is called and UserInterface creates the necessary World, Turtle, and WorldController instances as well as its visual components such as commandField. The user inputs forward 50 and clicks run. This is sent to the WorldController, which sends it the its World. The World utilizes Parser and CommandFactory to produce the appropriate Forward command subclass. This is now sent to be created as a Button to be used in the future if the user chooses to do so. At the same time, the World now has one command that it gives the Turtle to add to its queue and perform. The updated Turtle is now available in the updated World which is sent back to the UI through WorldController's getWorld method. The appropriate changes are now visualized on the screen for the user to see.</p>
<h2>User Interface</h2>
<p>At the most basic level there are two components to the <a href="https://github.com/duke-compsci308-spring2015/slogo_team07/blob/master/UIDiagram.jpg">user interface</a>. There is a space that allows the user to write Logo code, and there is a window which displays the results of running the code. The user can interact only with the space for writing code. First, there is a text box/field that allows the user to type actual code. The user can select custom settings such as line color, turtle image, line thickness, and background display color, and language. There are also options available that allow users to select recent commands, user-defined commands, and currently-saved variables available. These are features available for user convenience.</p>
<p>Error reporting is given in the form of a popup dialog box on screen. One way in which an error is generated is by attempting to run invalid code. This is defined as attempting to run code with invalid syntax, such that our parser can't make the data into a command. Invalid code can be achieved by typing out incorrect code or running code that might have been saved for later use by the user. Attempting to run the program when there is no code would be another example of invalid code. An error message is shown relaying this to the user.</p>
<h2>Design Details</h2>
<h3><a class="el" href="../../d0/d4b/class_main.html">Main</a></h3>
<p><a class="el" href="../../d0/d4b/class_main.html">Main</a> runs UserInterface.</p>
<h3>UserInterface</h3>
<p>The UserInterface will contain the visuals and how the user interacts with them. The command field will allow the users to enter commands to the turtle interactively and virtually displays the results of the turtle executing commands. When a button is pressed, the refresh() method will change the turtle based on the commands. The buttons held in this class allow the user to set a background color, choose a turtle image, and specify a pen color. There will be a field that shows commands previously run in the environment and variables currently available in the environment, as well as user defined commands. Users can also choose which language and access a help page. This class interacts with the WorldController. The resources needed will be the languages and the help page.</p><ul>
<li>void initialize()</li>
<li>void refresh()</li>
</ul>
<h3>WorldController</h3>
<p>The WorldController will be the controller of the MVC format. It keeps the model and view separate, getting information from the view to give to the model and vice versa. Holds the World.</p><ul>
<li>void update(String s)<ul>
<li>When an input string is detected, calls all the methods in world to parse and execute command</li>
<li>Sends information to the visualizer</li>
</ul>
</li>
<li>void clear()</li>
<li>World getWorld()</li>
</ul>
<h3>World (abstract)</h3>
<p>The World connects the Parser, and therefore the Commands, with the Turtle. This is how the commands are passed to the turtle to execute. This class can be extended to create any type of world, like finite or wrap-around.</p><ul>
<li>int getXSize()</li>
<li>int getYSize()</li>
<li>void setXSize(int x)</li>
<li>void setYSize(int y)</li>
<li>abstract void fixPosition()<ul>
<li>To be implemented in the UnboundedWorld, corrects position of turtle for wrap-around</li>
</ul>
</li>
<li>void listen(String s)<ul>
<li>Calls parse on the s through the parser</li>
<li>Passes command to the turtle</li>
<li>Calls act on the turtle</li>
</ul>
</li>
</ul>
<h3>BoundedWorld and UnboundedWorld</h3>
<p>These classes extend the abstract World class for the different possible edge types.</p>
<h3>Parser</h3>
<p>This class will parse the input strings into an implementable format. The Parser will pass the parsed string to the CommandFactory to generate the correct command. The Parser will return to World a queue of Commands to implement.</p><ul>
<li>Queue&lt;Command&gt; parse(String s)</li>
</ul>
<h3>CommandFactory</h3>
<p>We will create the correct type of Command based on the parsed string that was received from the Parser. This is where we will handle errors that may result from the user’s commands, resulting in a pop up box with the error. Holds a map of variables that the user has entered.</p>
<h3>Command (interface)</h3>
<p>The Command interface will be implemented by all the command classes. This is an interface because each command executes different instructions, so there are no methods in common and there will be no use for this to be an abstract class. The purpose of this class is to create a framework from which the same method can be called by the Turtle to perform any command. New commands can be created easily by extending this interface.</p><ul>
<li>abstract double run()</li>
</ul>
<h3>ButtonFactory</h3>
<p>Dynamically creates new choices for the user and sends them to be displayed, with regards to the features to show previously run commands, variables, and user-defined commands.</p><ul>
<li>Button createButton()</li>
</ul>
<h3>Turtle</h3>
<p>The Turtle is responsible for holding its current position and orientation and being able to move based on the instructions from the queue of Commands given to it by the World. The Turtle’s attributes can be changed here as well, like its image or pen color.</p><ul>
<li>void drawSelf(Group g)</li>
<li>boolean isDrawin()</li>
<li>boolean isVisible()</li>
<li>void setDrawing(boolean b)</li>
<li>void setVisible(boolean b)</li>
<li>int getX()</li>
<li>int getY()</li>
<li>void act()<ul>
<li>Performs Commands from queue of Commands</li>
</ul>
</li>
<li>void move(int pixels)</li>
<li>void rotate(double degrees)</li>
<li>void setHeading(double degrees)</li>
<li>void addCommands(Queue&lt;Command&gt; commands)</li>
</ul>
<h2>API Example code</h2>
<p>Reference https://github.com/duke-compsci308-spring2015/slogo_team07/blob/master/API.md "this"</p>
<p>The user types 'fd 50' in the command window, and sees the turtle move in the display window leaving a trail.</p>
<p>For convenience, set s = ‘fd 50’</p>
<p>UI.refresh(s) calls WorldController.update(s) which calls World.listen(s) which calls Parser.parse(s) which returns a one-element Queue of a new ForwardCommand with parameter list equal to {50} which is passed to Turtle.addCommand(s). World.listen(s) also calls Turtle.act(), which processes the command. UI.refresh(s) then references WorldController.getWorld() which returns the information and is updated by the UI.</p>
<h2>Design Considerations</h2>
<p>We discussed the use of factories for commands and buttons in order to maximize convenience and cleanliness in code. We also weighed the pros and cons on which class should act as our controller in MVC design. We eventually settled on WorldController because it already had access to both the UI as well as the World, which acts as our main component in the back end. We were concerned about how our program would store variables and throw exceptions if needed but settled on putting the hash map of variables in our command factory so that when initializing our commands, any faulty parameter data types would allow us to display a pop-up indiciating an error in our user's input. One significant change from our initial design of the program was our amount of get and set methods. After our readings, we decided on attempting to minimize the number of gets and sets so that there was the least amount of data sharing and a lot of encapsulation in our classes and objects. Finally, we discussed whether to utilize an abstract class or an interface for our Command class. We settled on an abstract class because the functionality of CommandFactory required us to be able to instantiate a general Command. Moreover, while an interface allows multiple behaviors to be implemented on one object, an abstract class demonstrates more of a direct inheritance. A lot of our design considerations and choices changed after class readings on interfaces and reconsiderations on possible code smells. By the end of it, we were really satisified with how our overall design turned out and believe the use of abstractions and our streamlined MVC design will make Sprint 3 much easier.</p>
<h2>Team Responsibilities</h2>
<p>Front end artists: James Mosca, Brandon Choi Back end artists: Thomas Bagley, Megan Gutter</p>
<p>Because of how complicated the back end is, the front end artists will definitely be contributing to back end as well depending how much help they need and on what they need help on.</p>
<p>James: <br />
 Primary: UserInterface, drawing functionality<br />
 Secondary: ImageView components<br />
</p>
<p>Brandon:  Primary: UserInterface, WorldController, <a class="el" href="../../d0/d4b/class_main.html">Main</a><br />
 Secondary: drawing functionality<br />
</p>
<p>Thomas:  Primary: Turtle, Command(s), CommandFactory<br />
 Secondary: ButtonFactory, Parser, World<br />
</p>
<p>Megan:  Primary: Parser, World<br />
 Secondary: Command(s)<br />
</p>
<p>We plan on meeting as often as possible in order to pair program. Since we now have a bigger team than last project, we will also meet with our respective front or back end partner and code and collaborate with them as well. We have established a messaging system for communication so that we can let each other know of any questions, concerns, or updates. In order to merge and change the master branch, everyone must first verbally or through GitHub comments approve the pull request and its changes. We hope to meet often in order to prevent merge errors in the future and so that everyone is aware of all components of our model-view-controller design. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 6 2015 04:21:07 for slogo_team07 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
